# Barplot representing the different protein amounts
sd_h3k27ac <- aggregate(protein ~ histone, data = protein_h3k27ac, FUN= "sd")
sd_h3k27me3 <- aggregate(protein ~ histone, data = protein_h3k27me3, FUN= "sd")
sd_h3k4me3 <- aggregate(protein ~ histone, data = protein_h3k4me3, FUN="sd")
all_histone_sd <- rbind(sd_h3k27ac, sd_h3k27me3, sd_h3k4me3)
all_histone_sd$dose <- as.numeric(all_histone_sd$dose)
View(all_histone_sd)
# Barplot representing the different protein amounts
sd_h3k27ac <- aggregate(protein ~ histone, data = protein_h3k27ac, FUN= "sd")
# Barplot representing the different protein amounts
sd_h3k27ac <- aggregate(protein ~ dose, data = protein_h3k27ac, FUN= "sd")
sd_h3k27me3 <- aggregate(protein ~ dose, data = protein_h3k27me3, FUN= "sd")
sd_h3k4me3 <- aggregate(protein ~ dose, data = protein_h3k4me3, FUN="sd")
all_histone_sd <- rbind(sd_h3k27ac, sd_h3k27me3, sd_h3k4me3)
all_histone_sd$dose <- as.numeric(all_histone_sd$dose)
View(all_histone_sd)
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855)) +
geom_errorbar(aes(ymin = protein - all_histone_sd, ymax = protein + all_histone_sd), width = 0.2)  # Vertical error bars
all_histone_protein <- rbind(all_histone_sd, all_histone_protein)
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855)) +
geom_errorbar(aes(ymin = protein - all_histone_sd, ymax = protein + all_histone_sd), width = 0.2)  # Vertical error bars
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855)) +
geom_errorbar(aes(ymin = mean - all_histone_sd, ymax = mean + all_histone_sd), width = 0.2)  # Vertical error bars
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855)) +
geom_errorbar(aes(ymin = mean - all_histone_sd, ymax = mean + all_histone_sd), width = 0.2)  # Vertical error bars
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855)) +
geom_errorbar(aes(ymin = protein$mean - all_histone_sd, ymax = mean + all_histone_sd), width = 0.2)  # Vertical error bars
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855)) +
geom_errorbar(aes(ymin = protein - all_histone_sd, ymax = protein + all_histone_sd), width = 0.2)  # Vertical error bars
View(all_histone_sd)
# Barplot representing the different protein amounts
sd_h3k27ac <- aggregate(protein ~ dose, data = protein_h3k27ac, FUN= "sd")
sd_h3k27me3 <- aggregate(protein ~ dose, data = protein_h3k27me3, FUN= "sd")
sd_h3k4me3 <- aggregate(protein ~ dose, data = protein_h3k4me3, FUN="sd")
all_histone_sd <- rbind(sd_h3k27ac, sd_h3k27me3, sd_h3k4me3)
all_histone_sd$dose <- as.numeric(all_histone_sd$dose)
all_histone_sd$dose <- as.numeric(all_histone_sd$dose)
protein_h3k4me3 <- data.frame((((h3k4me3$absorbance) - 0.043) / ((h3k4me3$protein) * 0.149)) * 1000, fun=sd)
View(protein_amount_h3k27me3)
protein_h3k4me3 <- data.frame((((h3k4me3$absorbance) - 0.043) / ((h3k4me3$protein) * 0.149)) * 1000)
, fun=sd
protein_h3k4me3 <- data.frame((((h3k4me3$absorbance) - 0.043) / ((h3k4me3$protein) * 0.149)) * 1000, fun=sd)
View(protein_h3k4me3)
protein_h3k4me3 <- data.frame((((h3k4me3$absorbance) - 0.043) / ((h3k4me3$protein) * 0.149)) * 1000)
# Barplot representing the different protein amounts
sd_h3k27ac <- aggregate(protein ~ dose, data = protein_h3k27ac, FUN= "sd")
View(sd_h3k27ac)
sd_h3k27ac$histone <- c("h3k27ac")
View(sd_h3k27ac)
sd_h3k27me3 <- aggregate(protein ~ dose, data = protein_h3k27me3, FUN= "sd")
sd_h3k27me3$histone <- c("h3k27me3")
sd_h3k4me3 <- aggregate(protein ~ dose, data = protein_h3k4me3, FUN="sd")
sd_h3k4me3$histone <- c("h3k4me3")
all_histone_sd <- rbind(sd_h3k27ac, sd_h3k27me3, sd_h3k4me3)
all_histone_sd$dose <- as.numeric(all_histone_sd$dose)
View(all_histone_sd)
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855)) +
geom_errorbar(aes(ymin = protein - all_histone_sd, ymax = protein + all_histone_sd), width = 0.2)  # Vertical error bars
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855))
all_protein_plot <- ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "summary",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855))
all_protein_plot
all_protein_plot <- all_protein_plot + stat_summary(
fun.data = "mean_cl_normal",  # Use "mean_cl_normal" for SD bars
geom = "errorbar",  # Use error bars
width = 0.2  # Adjust the width of error bars as needed
)
all_protein_plot <- all_protein_plot + stat_summary(fun.data = "mean_cl_normal",  geom = "errorbar", width = 0.2)
all_protein_plot <- all_protein_plot + stat_summary(fun.all_histone_protein = "mean_cl_normal",  geom = "errorbar", width = 0.2)
all_protein_plot <- ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "mean",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855))
all_protein_plot <- ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "identity",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855))
all_protein_plot
all_protein_plot <- ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "identity",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855))
ggplot(all_histone_protein, aes(x=dose, y=protein)) +
geom_bar(stat = "identity",  width = 1.5, aes(fill=histone),
position = "dodge", fun="mean",
show.legend = T) +
xlab('Dosage(ug/ul)') +
ylab('Histone Protein Amount') +
scale_fill_manual((name="Histone"),
labels=c("H3K27ac","H3K27me3","H3K4me3"),
values=wes_palette("Moonrise3")) +
theme_light() +
theme(legend.position=c(0.9,0.855))
source("C:/Users/bjork/Downloads/histone_coding.R", echo=TRUE)
## Set your working directory
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/")
## Import the libraries that we're likely to need in this session
library(DESeq2)
# Try with new counts table from filtered transcriptome assembly
countsTable <- read.table("salmon.isoform.counts.matrix.filteredAssembly", header=TRUE, row.names=1)
head(countsTable)
dim(countsTable)
View(countsTable)
countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
head(countsTableRound)
#import the sample discription table
conds <- read.delim("ahud_samples_R.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)
head(conds)
dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds,
design= ~ treatment)
dim(dds)
dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds,
design= ~ treatment)
dim(dds)
# Filter
dds <- dds[rowSums(counts(dds) >= 30) >= 28,]
nrow(dds)
# Subset the DESeqDataSet to the specific level of the "generation" factor
dds_F0 <- subset(dds, select = generation == 'F0')
dim(dds_F0)
# Perform DESeq2 analysis on the subset
dds_F0 <- DESeq(dds_F0)
resultsNames(dds_F0)
res_F0_OWvAM <- results(dds_F0, name="treatment_OW_vs_AM", alpha=0.05)
res_F0_OWvAM <- res_F0_OWvAM[order(res_F0_OWvAM$padj),]
head(res_F0_OWvAM)
summary(res_F0_OWvAM)
res_F0_OWAvAM <- results(dds_F0, name="treatment_OWA_vs_AM", alpha=0.05)
res_F0_OWAvAM <- res_F0_OWAvAM[order(res_F0_OWAvAM$padj),]
head(res_F0_OWAvAM)
summary(res_F0_OWAvAM)
summary(res_F0_OAvAM)
resultsNames(dds_F0)
################## Save all the results as csv to go into GOMWU
library(tidyr)
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OWvAM_df <- data.frame(transcriptID = rownames(res_F0_OWvAM), res_F0_OWvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OWvAM_df <- separate(res_F0_OWvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OWvAM_df$transcriptID_trim <- paste(res_F0_OWvAM_df$part1, res_F0_OWvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OWvAM_df <- res_F0_OWvAM_df[, !(names(res_F0_OWvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OWvAM_df, file = "res_F0_OWvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OW <- res_F0_OWvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OW, file = "res_F0_OWvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OWAvAM_df <- data.frame(transcriptID = rownames(res_F0_OWAvAM), res_F0_OWAvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OWAvAM_df <- separate(res_F0_OWAvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OWAvAM_df$transcriptID_trim <- paste(res_F0_OWAvAM_df$part1, res_F0_OWAvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OWAvAM_df <- res_F0_OWAvAM_df[, !(names(res_F0_OWAvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OWAvAM_df, file = "res_F0_OWAvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OWA <- res_F0_OWAvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OWA, file = "res_F0_OWAvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OAvAM_df <- data.frame(transcriptID = rownames(res_F0_OAvAM), res_F0_OAvAM)
res_F0_OWvAM <- results(dds_F0, name="treatment_OW_vs_AM", alpha=0.05)
res_F0_OWvAM <- res_F0_OWvAM[order(res_F0_OWvAM$padj),]
head(res_F0_OWvAM)
summary(res_F0_OWvAM)
res_F0_OWAvAM <- results(dds_F0, name="treatment_OWA_vs_AM", alpha=0.05)
res_F0_OWAvAM <- res_F0_OWAvAM[order(res_F0_OWAvAM$padj),]
head(res_F0_OWAvAM)
summary(res_F0_OWAvAM)
res_F0_OAvAM <- results(dds_F0, name="treatment_OA_vs_AM", alpha=0.05)
res_F0_OAvAM <- res_F0_OAvAM[order(res_F0_OAvAM$padj),]
head(res_F0_OAvAM)
summary(res_F0_OAvAM)
################## Save all the results as csv to go into GOMWU
library(tidyr)
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OWvAM_df <- data.frame(transcriptID = rownames(res_F0_OWvAM), res_F0_OWvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OWvAM_df <- separate(res_F0_OWvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OWvAM_df$transcriptID_trim <- paste(res_F0_OWvAM_df$part1, res_F0_OWvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OWvAM_df <- res_F0_OWvAM_df[, !(names(res_F0_OWvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OWvAM_df, file = "res_F0_OWvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OW <- res_F0_OWvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OW, file = "res_F0_OWvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OWAvAM_df <- data.frame(transcriptID = rownames(res_F0_OWAvAM), res_F0_OWAvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OWAvAM_df <- separate(res_F0_OWAvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OWAvAM_df$transcriptID_trim <- paste(res_F0_OWAvAM_df$part1, res_F0_OWAvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OWAvAM_df <- res_F0_OWAvAM_df[, !(names(res_F0_OWAvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OWAvAM_df, file = "res_F0_OWAvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OWA <- res_F0_OWAvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OWA, file = "res_F0_OWAvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OAvAM_df <- data.frame(transcriptID = rownames(res_F0_OAvAM), res_F0_OAvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OAvAM_df <- separate(res_F0_OAvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OAvAM_df$transcriptID_trim <- paste(res_F0_OAvAM_df$part1, res_F0_OAvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OAvAM_df <- res_F0_OAvAM_df[, !(names(res_F0_OAvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OAvAM_df, file = "res_F0_OAvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OA <- res_F0_OAvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OA, file = "res_F0_OAvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
## Set your working directory
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
# OAvAM:
input="res_F0_OAvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
# OWAvAM:
input="res_F0_OWAvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
# OWvAM:
input="res_F0_0WvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25 # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25) # threshold for merging similar (gene-sharing) terms. See README for details.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25) # threshold for merging similar (gene-sharing) terms. See README for details.
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
View(res_F0_OWvAM)
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
# OWvAM:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
# OWvAM:
input=read.csv("res_F0_OWvAM_LFC.csv") # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25 # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("C:/Users/bjork/Documents/GitHub/Ecological_Genomics_23/PopGenomics/results/GOMWU")
# OWvAM:
input=read.csv("res_F0_OWvAM_LFC.csv") # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25 # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
